# -*- coding: utf-8 -*-
"""Subspace Outlier Detection (SOD)
"""
# Author: Yahya Almardeny <almardeny@gmail.com>
# License: MIT

from sklearn.neighbors import NearestNeighbors
import numpy as np
from sklearn.utils import check_array
from .base import BaseDetector


class SOD(BaseDetector):
    """
    Subspace outlier detection (SOD) algorithm
    The implementation is based on the work of
    Krigel, H.P., Kroger, P., Schubert, E., Zimek, A.,
    Outlier detection in axis-parallel subspaces of high dimensional data, 2009.

    Parameters
    ----------
    contamination : float in (0., 0.5), optional (default=0.1)
        The amount of contamination of the data set, i.e.
        the proportion of outliers in the data set. Used when fitting to
        define the threshold on the decision function.

    n_neighbors : int, optional (default=20)
        Number of neighbors to use by default for k neighbors queries.

    ref_set: int, optional (default=10)
        specifies the number of shared nearest neighbors to create the reference set.
        Note that ref_set must be smaller than n_neighbors.

    alpha: float in (0., 1.), optional (default=0.8)
           specifies the lower limit for selecting subspace.
           0.8 is set as default as suggested in the original paper.

    Attributes
    ----------
    decision_scores_ : numpy array of shape (n_samples,)
        The outlier scores of the training data.
        The higher, the more abnormal. Outliers tend to have higher
        scores. This value is available once the detector is
        fitted.

    threshold_ : float
        The threshold is based on ``contamination``. It is the
        ``n_samples * contamination`` most abnormal samples in
        ``decision_scores_``. The threshold is calculated for generating
        binary outlier labels.

    labels_ : int, either 0 or 1
        The binary labels of the training data. 0 stands for inliers
        and 1 for outliers/anomalies. It is generated by applying
        ``threshold_`` on ``decision_scores_``.

    n_neighbors_: int
        Number of neighbors to use by default for k neighbors queries.

    ref_set_: int
        Number of shared nearest neighbors included in the reference set.

    alpha_: float
        The lower limit for selecting subspace.
    """
    def __init__(self, contamination=0.1, n_neighbors=20, ref_set=10, alpha=0.8):
        super(SOD, self).__init__(contamination=contamination)
        self.n_neighbors_ = n_neighbors
        self.ref_set_ = ref_set
        self.alpha_ = alpha
        self.__check_params()
        self.decision_scores_ = None

    def fit(self, X, y=None):
        """Fit detector. y is optional for unsupervised methods.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features)
            The input samples.

        y : numpy array of shape (n_samples,), optional (default=None)
            The ground truth of the input samples (labels).
        """
        # validate inputs X and y (optional)
        X = check_array(X)
        self._set_n_classes(y)
        self.decision_scores_ = self.decision_function(X)
        self._process_decision_scores()

        return self

    def decision_function(self, X):
        """Predict raw anomaly score of X using the fitted detector.
        The anomaly score of an input sample is computed based on different
        detector algorithms. For consistency, outliers are assigned with
        larger anomaly scores.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features)
            The training input samples. Sparse matrices are accepted only
            if they are supported by the base estimator.

        Returns
        -------
        anomaly_scores : numpy array of shape (n_samples,)
            The anomaly score of the input samples.
        """
        return self._sod(X)

    def __snn(self, X):
        """
        This function is called internally to calculate the shared nearest neighbors (SNN).
        SNN is reported to be more robust than k nearest neighbors.
        Firstly, the k nearest neighbor distances for each observation is calculated.
        Then, the shared nearest neighbor similarity is calculated based on
        the result of k nearest neighbor.
        Note that k must be greater than l.
        :return: numpy array containing the indices of top k shared nearest neighbors for
                 each observation.
        """
        knn = NearestNeighbors(n_neighbors=self.n_neighbors_)
        knn.fit(X)
        # Get the knn index
        ind = knn.kneighbors(return_distance=False)
        n = ind.shape[0]
        _count = np.zeros(shape=(n, self.ref_set_), dtype=np.uint16)
        # Count the distance using the customized function
        for i in range(n):
            # The point should not be in its reference set,
            # but we need it temporarily to maintain indices order,
            # it has the max possible value: 65535 (max unsigned int16)
            # so it'll be always as first index after sorting
            temp = np.sum(np.isin(ind, ind[i]), axis=1).ravel()
            temp[i] = np.iinfo(np.uint16).max
            # sorting after each iteration because argsort is int64
            # and cannot handle big data
            _count[i] = np.argsort(temp)[::-1][1:self.ref_set_+1]

        return _count

    def _sod(self, X):
        """
        Subspace outlier detection (SOD) algorithm
        This function is called internally to perform subspace outlier detection algorithm.
        The implemented method is based on the work of
        Krigel, H.P., Kroger, P., Schubert, E., Zimek, A., Outlier detection in axis-parallel
        subspaces of high dimensional data, 2009.
        :return: numpy array containing the SOD outlier scores for each observation
        """
        refInds = self.__snn(X)
        result = []
        for i in range(X.shape[0]):
            obs = X[i]
            ref = X[refInds[i, ], ]
            means = np.mean(ref, axis=0)  # mean of each column
            # average squared distance of the reference to the mean
            varTotal = sum(sum(np.square(ref - means)))/self.ref_set_
            varExpect = self.alpha_ * varTotal / X.shape[1]
            varActual = np.var(ref, axis=0)  # variance of each attribute
            varInds = [1 if (i < varExpect) else 0 for i in varActual]
            relDim = sum(varInds)
            score_ = np.sqrt(np.dot(varInds, np.square(obs - means))/relDim) if relDim > 0 else 0.
            result.append(score_)
        return np.array(result)

    def __check_params(self):
        """
        Internal function to check and validate parameters passed by user
        """
        if self.n_neighbors_ is None:
            raise ValueError("n_neighbors cannot be None")
        if self.n_neighbors_ <= 0:
            raise ValueError("Expected n_neighbors > 0. Got %d" % self.n_neighbors_)
        if not np.issubdtype(type(self.n_neighbors_), np.integer):
            raise TypeError("n_neighbors does not take %s value, enter integer value" %
                            type(self.n_neighbors_))

        if self.ref_set_ is None:
            raise ValueError("ref_set cannot be None")
        if self.ref_set_ <= 0:
            raise ValueError("Expected ref_set > 0. Got %d" % self.ref_set_)
        if self.ref_set_ >= self.n_neighbors_:
            raise TypeError("n_neighbors should be greater than ref_set")
        if not np.issubdtype(type(self.ref_set_), np.integer):
            raise TypeError("ref_set does not take %s value, enter integer value" %
                            type(self.ref_set_))

        if self.alpha_ is None:
            raise TypeError("alpha cannot be None")
        if not 0. < self.alpha_ <= 1.0:
            raise ValueError("Expected alpha in (0.0, 1.0). Got %d" % self.alpha_)
        if not np.issubdtype(type(self.alpha_), np.float):
            raise TypeError("alpha does not take %s value, enter integer value" %
                            type(self.alpha_))
